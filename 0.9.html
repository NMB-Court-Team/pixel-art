<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>像素画编辑器</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: Segoe UI, Arial, sans-serif;
            min-height: 100vh;
            padding: 20px
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 2.2em
        }

        .main-content {
            display: flex;
            gap: 30px;
            flex-wrap: wrap
        }

        .canvas-area {
            flex: 1;
            min-width: 500px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative
        }

        .remap-cell {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid rgba(0, 0, 0, 0.2);
        }

        .remap-cell.selected {
            outline: 2px solid #ff9800;
        }

        #canvasWrapper {
            position: relative;
        }

        #canvas {
            border: 3px solid #667eea;
            background: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            display: inline-grid;
            cursor: crosshair;
            user-select: none;
        }

        #previewLayer {
            position: absolute;
            top: 3px;
            left: 3px;
            pointer-events: none;
            z-index: 40
        }

        #selectionLayer {
            position: absolute;
            top: 3px;
            left: 3px;
            pointer-events: none;
            z-index: 50
        }

        .pixel {
            border: 1px solid rgba(0, 0, 0, 0.05);
            transition: opacity .08s
        }

        .control-panel {
            width: 360px;
            display: flex;
            flex-direction: column;
            gap: 4px
        }

        .panel-section {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1)
        }

        .panel-section h3 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1em
        }

        .btn-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px
        }

        button {
            padding: 7px 14px;
            border: none;
            border-radius: 8px;
            background: #667eea;
            color: #fff;
            cursor: pointer;
            font-weight: 600;
            position: relative
        }

        button.active {
            background: #764ba2;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.15)
        }

        .color-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px
        }

        .color-btn {
            width: 35px;
            height: 35px;
            border-radius: 8px;
            border: 3px solid transparent;
            cursor: pointer
        }

        .color-btn.selected {
            border-color: #667eea;
            box-shadow: 0 0 0 2px white, 0 0 0 4px #667eea
        }

        textarea {
            width: 100%;
            min-height: 150px;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-family: monospace
        }

        .size-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px
        }

        input[type="number"] {
            width: 80px;
            padding: 8px;
            border-radius: 8px;
            border: 2px solid #ddd
        }

        .small-note {
            font-size: 12px;
            color: #666;
            margin-top: 8px
        }

        /* 选区样式：橙色半透明斜线 */
        .sel-pixel {
            position: absolute;
            pointer-events: none;
            background-image: repeating-linear-gradient(135deg, rgba(255, 165, 0, 0.25) 0 6px, transparent 6px 12px);
            mix-blend-mode: normal;
            z-index: 50;
        }

        .sel-border {
            position: absolute;
            pointer-events: none;
            border: 1px dashed rgba(255, 140, 0, 0.95);
            box-sizing: border-box;
            z-index: 55;
        }

        .sel-preview {
            position: absolute;
            pointer-events: none;
            background-image: repeating-linear-gradient(135deg, rgba(255, 165, 0, 0.18) 0 6px, transparent 6px 12px);
            z-index: 49;
            box-sizing: border-box;
        }

        /* hover tooltip (simple) */
        button[title]:hover::after {
            content: attr(title);
            position: absolute;
            left: 50%;
            transform: translate(-50%, -140%);
            background: rgba(0, 0, 0, 0.78);
            color: #fff;
            padding: 6px 8px;
            border-radius: 6px;
            white-space: nowrap;
            font-size: 12px;
            z-index: 80;
        }

        .no-grid .pixel {
            border: none !important;
        }

        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            text-align: center;
            border-radius: 5px;
            padding: 10px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        .toast.show {
            opacity: 1;
        }
    /* 头像容器（右下角固定） */
    #toyAvatar {
      position: fixed;
      right: 18px;
      bottom: 18px;
      width: 72px;
      height: 72px;
      border-radius: 18px;
      background: linear-gradient(180deg,#ffecec,#ffd9d9);
      box-shadow: 0 8px 22px rgba(0,0,0,0.25);
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      z-index:9999;
      transform-origin: center;
      transition: transform 120ms ease, box-shadow 120ms ease;
      user-select:none;
    }

    #toyAvatar .face {
      width:64%; height:64%;
      display:block;
    }
    @keyframes squeeze {
      0% { transform: scale(1,1); }
      20% { transform: scale(1.14, 0.78); }
      55% { transform: scale(0.95, 1.05); }
      100% { transform: scale(1,1); }
    }
    #toyAvatar.squeeze {
      animation: squeeze 360ms cubic-bezier(.2,.9,.3,1);
    }
    #toyAvatar:active { box-shadow: 0 4px 10px rgba(0,0,0,0.28); }
    #toyAvatar .hint {
      position:absolute;
      right:25%;
      bottom:150%;
      margin-bottom:6px;
      background:rgba(0,0,0,0.75);
      color:#fff;
      padding:6px 8px;
      border-radius:6px;
      font-size:12px;
      white-space:nowrap;
      opacity:0;
      transform: translateY(6px);
      transition:opacity .12s, transform .12s;
      pointer-events:none;
    }
    #toyAvatar:hover .hint { opacity:1; transform: translateY(0); }

    </style>
</head>
<body>
<div class="container">
    <h1>🎨 像素画编辑器</h1>
    <div class="main-content">
        <div class="canvas-area">
            <div id="canvasWrapper">
                <div id="canvas"></div>
                <div id="previewLayer"></div>
                <div id="selectionLayer"></div>
            </div>
            <!-- 📝 使用说明区域 -->
            <div id="helpSection" style="margin-top:20px;padding:12px 16px;border-radius:8px;
            background:#f9fafc;border:1px solid #d0d4e4;max-width:800px;line-height:1.6;">
                <h2 style="margin-top:0;">🧭 使用说明</h2>
                <ul style="margin:0;padding-left:20px;">
                    <li><b>🧩 网格</b> 按钮：显示 / 隐藏画布网格</li>
                    <li><b>Alt</b>：临时进入取色模式, 松开后恢复上一个工具</li>
                    <li><b>选区</b>高亮为橙色半透明斜线, 粘贴后可拖动, 按 Enter 放置, Esc 取消</li>
                    <li><b>Shift + 拖动</b>：在矩形选区模式下叠加选区</li>
                    <li><b>Ctrl + C / X / V</b>：复制 / 剪切 / 粘贴选区</li>
                    <li><b>Enter</b>：确认移动或粘贴的预览</li>
                    <li><b>Esc</b>：取消粘贴或清除选区</li>
                    <li><b>🎨 颜色重映射</b> 点击两个颜色进行互换, 将颜色重新映射</li>
                    <li><b>🎲</b> 按钮：随机打乱颜色, 重新映射</li>
                    <li><b>↩️</b> 按钮：恢复原始颜色映射</li>
                    <li><b>保存与导出</b>：点击右上角的导出按钮保存为文件</li>
                </ul>
                <p style="margin-top:10px;color:#555;">
                    💡 提示：选区支持矩形和手涂两种方式；手涂选取为逐像素切换选中状态。
                </p>
            </div>
        </div>

        <div class="control-panel">
            <div class="panel-section">
                <h3>工具</h3>
                <div class="btn-group">
                    <button id="pen" class="active" title="画笔 (左键绘制)">🖌️ 画笔</button>
                    <button id="eraser" title="橡皮擦">🧹 橡皮擦</button>
                    <button id="eyedropper" title="取色">🎯 取色</button>
                    <button id="line" title="直线">📏 直线</button>
                    <button id="rect" title="矩形">⬛ 矩形</button>
                    <button id="circle" title="圆形">⚪ 圆形</button>
                    <button id="fill" title="填充">💧 填充</button>
                    <button id="undo" title="撤回 (Ctrl+Z)">↩️ 撤回</button>
                    <button id="redo" title="重做 (Ctrl+Y)">↪️ 重做</button>
                    <button id="clear" style="background:#e74c3c" title="清空">🗑️ 清空</button>
                    <button id="toggleGrid" title="显示/隐藏网格">🧩 网格</button>
                </div>
                <div style="margin-top:12px">
                    <strong>选区</strong>
                    <div class="btn-group" style="margin-top:8px">
                        <button id="selRect" title="矩形选取 (Shift 叠加)">▭ 矩形选取</button>
                        <button id="selFree" title="手涂逐像素选取（再次涂则取消）">✍️ 手涂选取</button>
                        <button id="selMove" title="移动选区 (剪切并粘贴)">⤴️ 移动</button>
                        <button id="selCopy" title="复制选区 (Ctrl+C)">📄 复制</button>
                        <button id="selCut" title="剪切选区 (Ctrl+X)">✂️ 剪切</button>
                        <button id="selPaste" title="粘贴 (Ctrl+V)">📌 粘贴</button>
                        <button id="selClear" title="清除选区 (Esc)">✖️ 清除选区</button>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <h3>对称模式</h3>
                <div class="btn-group">
                    <button class="symmetry-btn" data-mode="none" title="无对称">无对称</button>
                    <button class="symmetry-btn" data-mode="horizontal" title="水平镜像">水平镜像</button>
                    <button class="symmetry-btn" data-mode="vertical" title="竖直镜像">竖直镜像</button>
                    <button class="symmetry-btn" data-mode="both" title="双向镜像">双向镜像</button>
                    <button class="symmetry-btn" data-mode="rotate4" title="4向旋转">4向旋转</button>
                    <button class="symmetry-btn" data-mode="rotate8" title="8向旋转">8向旋转</button>
                </div>
            </div>

            <div class="panel-section">
                <h3>调色板</h3>
                <div class="color-palette" id="colorPalette"></div>
                <div style="display:flex;gap:10px;margin-top:10px">
                    <!--input type="color" id="colorPicker" value="#000000"-->
                    <!--button id="addColor" title="添加颜色">➕ 添加</button-->
                </div>
                <div id="paletteRemap" style="margin-top:12px;padding:10px;border:1px solid #ccc;border-radius:8px;">
                    <div style="display:flex;align-items:center;gap:10px;margin-bottom:8px;">
                        <strong>🎨 颜色重映射：</strong>
                        <button id="shuffleColors" title="随机打乱调色板顺序">🎲</button>
                        <button id="resetRemap" title="恢复原始顺序">↩️</button>
                    </div>
                    <div id="remapGrid"
                         style="display:grid;grid-template-columns:repeat(auto-fill, 30px);gap:8px;"></div>
                    <small style="color:#666;">点击两个颜色交换它们的映射, 或使用 🎲 随机打乱。</small>
                </div>

            </div>

            <div class="panel-section">
                <h3>导出/导入</h3>
                <div class="btn-group" style="margin-bottom:10px">
                    <button id="exportBtn" style="flex:1">📋 导出/复制到剪贴板</button>
                    <button id="importBtn" style="flex:1;background:#27ae60">📥 导入/从剪贴板导入</button>
                    <button id="importImage" title="导入图片">🖼 导入图片</button>
                </div>
                <textarea id="exportOutput" placeholder="导出的像素画数据会显示在这里..."></textarea>
                <div style="margin-top:8px;font-size:12px;color:#666">💡 每一行形如 <code>- [0, 1, 2, ...]</code>,
                    每个数字代表颜色在调色板中的序号（0-F）, 从左到右、从上到下排列。
                </div>
            </div>
            <!--div class="panel-section">
              <h3>画布大小</h3>
              <div class="size-controls">
                <label>宽:</label>
                <input type="number" id="canvasWidth" value="45" min="5" max="100">
                <label>高:</label>
                <input type="number" id="canvasHeight" value="45" min="5" max="100">
              </div>
              <button id="resizeCanvas" style="margin-top:10px;width:100%">应用尺寸</button>
            </div-->
            <div class="panel-section">
                <h3>
                    观看直播解锁更多功能
                </h3>
                <button id="unlock" style="margin-top:10px;width:100%" onclick="handleUnlockClick()">前往直播间</button>
            </div>
        </div>
    </div>
</div>
<script>
// 检测是否为移动设备
function isMobileDevice() {
    return (typeof window.orientation !== "undefined") || (navigator.userAgent.indexOf('IEMobile') !== -1);
}

// 如果是移动设备，则重定向到提示页面
if (isMobileDevice()) {
    alert("像素画编辑器不支持移动设备访问，部分工具会无法使用，请使用桌面浏览器获得完整体验");
}
/* ====== 基础配置 ====== */
let COLS = 45, ROWS = 45;
let PIXEL_SIZE = 10;
const MAX_HISTORY = 500;

/* ====== 状态 ====== */
let currentColor = "#000000";
let tool = "pen";
let symmetryMode = "none";

let previousTool = null;   // 用来临时记住上一个工具
let isColorPicking = false;

/* ====== 选区状态（替换逻辑） ====== */
let selectionMode = null; // 'rect' | 'free' | 'move' | 'paste' | null
let selectionPixels = new Set(); // "x,y"
let selectionBounds = null;
let clipboard = null; // {w,h,cells}
let pasteOffset = null; // {x,y}
let moveOrigin = null; // for move: array of {x,y,oldColor}
let isSelecting = false, isDraggingPaste = false;
let lastToggledKey = null;

/* ====== 数据结构 ====== */
let colorPalette = [
    "#FFFFFF", "#D3D3D3", "#808080", "#000000",
    "#B02E26", "#5E7C16", "#835432", "#3C44AA",
    "#8932B8", "#169C9C", "#F38BAA", "#80C71F",
    "#FED83D", "#3AB3DA", "#C74EBD", "#F9801D"
];

let pixelData = [];           // ROWS x COLS 的颜色值
let historyStack = [];        // 历史
let redoStack = [];
let currentStep = null;       // 临时记录

let moveBackup = null;   // 存放移动前的像素数据
let isMoving = false;    // 标识当前是否在移动

let currentMousePos = {x: 0, y: 0}


/* ====== DOM 元素 ====== */
const canvas = document.getElementById("canvas");
const canvasWrapper = document.getElementById("canvasWrapper");
const previewLayer = document.getElementById("previewLayer");
const selectionLayer = document.getElementById("selectionLayer");
const colorPaletteContainer = document.getElementById("colorPalette");
const exportOutput = document.getElementById("exportOutput");

/* ====== 切换工具 ======*/
function setActiveTool(toolName) {
    tool = toolName;
    document.querySelectorAll(".btn-group button").forEach(b => b.classList.remove("active"));
    const btn = document.getElementById(toolName);
    if (btn) btn.classList.add("active");
    refreshSymmetry()
}

function refreshSymmetry() {
    document.querySelectorAll(".symmetry-btn").forEach(b => {
        if (b.dataset.mode === symmetryMode) {
            b.classList.add("active")
        } else {
            b.classList.remove("active")
        }
    });
}

function setActiveSelection(btnId) {
    document.querySelectorAll('#selRect,#selFree').forEach(b => b.classList.remove('active'));
    const btn = document.getElementById(btnId);
    if (btn) btn.classList.add('active');
    refreshSymmetry()
}

/* ====== 初始化数据/画布 ====== */
function initData() {
    pixelData = Array.from({length: ROWS}, () => Array.from({length: COLS}, () => colorPalette[0]));
}

function resizeWrapper() {
    PIXEL_SIZE = Math.min(Math.min(window.innerWidth * 0.0125, window.innerHeight * 0.03), 20) || 10
    canvas.style.gridTemplateColumns = `repeat(${COLS}, ${PIXEL_SIZE}px)`;
    canvas.style.gridTemplateRows = `repeat(${ROWS}, ${PIXEL_SIZE}px)`;
    canvas.style.width = (COLS * PIXEL_SIZE) + "px";
    canvas.style.height = (ROWS * PIXEL_SIZE) + "px";
    canvasWrapper.style.width = (COLS * PIXEL_SIZE + 18) + "px";
    canvasWrapper.style.height = (ROWS * PIXEL_SIZE + 18) + "px";
    previewLayer.style.width = (COLS * PIXEL_SIZE) + "px";
    previewLayer.style.height = (ROWS * PIXEL_SIZE) + "px";
    selectionLayer.style.width = (COLS * PIXEL_SIZE) + "px";
    selectionLayer.style.height = (ROWS * PIXEL_SIZE) + "px";
    document.querySelectorAll(".pixel").forEach(p => {
        p.style.width = `${PIXEL_SIZE}px`;
        p.style.height = `${PIXEL_SIZE}px`;
    });
}

window.addEventListener("resize", resizeWrapper);

function initCanvas() {
    canvas.innerHTML = "";
    resizeWrapper();

    for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
            const d = document.createElement("div");
            d.className = "pixel";
            d.dataset.x = x;
            d.dataset.y = y;
            d.style.width = PIXEL_SIZE + "px";
            d.style.height = PIXEL_SIZE + "px";
            d.style.backgroundColor = pixelData[y][x];
            canvas.appendChild(d);
        }
    }
    renderSelectionLayer();
}

// === 颜色重映射 ===
// basePalette: 初始调色板（不变, 用作“索引基准”）
// currentMapping: 当前 mapping 状态（currentMapping[i] = 当前显示为原始索引 i 的颜色）
let basePalette = colorPalette.slice();     // 取当前主调色板快照（调用 initRemapPanel 时重新设）
let currentMapping = basePalette.slice();   // 当前 index -> color 映射（初始时为 identity）
let remapSelected = null;

// 初始化 / 渲染 remap 面板（调用位置：renderColorPalette() 后或 init 时）
function initRemapPanel() {
    // 如果调色板变了（新增颜色）, 重置 basePalette, 保持长度一致
    basePalette = colorPalette.slice();
    if (!currentMapping || currentMapping.length !== basePalette.length) currentMapping = basePalette.slice();

    const grid = document.getElementById("remapGrid");
    if (!grid) return; // 如果 DOM 没有这个容器就直接返回
    grid.innerHTML = "";
    basePalette.forEach((c, idx) => {
        const cell = document.createElement("div");
        cell.className = "remap-cell";
        cell.style.backgroundColor = currentMapping[idx];
        cell.dataset.index = idx;
        cell.addEventListener("click", () => onRemapClick(idx, cell));
        grid.appendChild(cell);
    });
}

// 刷新 remap 面板显示（颜色/选中状态）
function refreshRemapGrid() {
    const grid = document.getElementById("remapGrid");
    if (!grid) return;
    grid.querySelectorAll(".remap-cell").forEach(cell => {
        const idx = Number(cell.dataset.index);
        cell.style.backgroundColor = currentMapping[idx];
        cell.classList.remove("selected");
    });
    remapSelected = null;
}

/*
 applyPaletteMapping(newMapping)
  - newMapping: 长度必须等于 basePalette.length
  - 工作方式：基于 currentMapping（当前显示颜色）建反表 currentColor -> originalIndex
    对画布每像素查到 originalIndex 后用 newMapping[index] 替换像素颜色
  - 记录差异并 pushHistory, 使操作可撤回
*/
function applyPaletteMapping(newMapping) {
    if (!Array.isArray(newMapping) || newMapping.length !== basePalette.length) {
        console.warn("remap length mismatch", newMapping, basePalette);
        return;
    }

    // 反向表：当前显示颜色 -> original index
    const reverse = new Map();
    for (let i = 0; i < currentMapping.length; i++) {
        reverse.set(currentMapping[i], i);
    }

    const step = []; // 用于撤回
    for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
            const oldColor = pixelData[y][x];
            const idx = reverse.has(oldColor) ? reverse.get(oldColor) : undefined;
            if (typeof idx === "number") {
                const newColor = newMapping[idx];
                if (newColor !== oldColor) {
                    step.push({x, y, oldColor, newColor});
                    // 直接写 DOM & 数据
                    setPixelDirect(x, y, newColor);
                }
            }
            // 如果该像素不是调色板颜色（未在 reverse 中）, 则保持不变
        }
    }

    if (step.length > 0) pushHistory(step); // 支持撤回
    currentMapping = newMapping.slice();     // 更新当前 mapping 状态
    refreshRemapGrid();
}

// 点击 remap 单元格：实现“选两个格子互换映射并立即应用”
function onRemapClick(idx, cell) {
    if (remapSelected === null) {
        remapSelected = idx;
        cell.classList.add("selected");
        return;
    }
    if (remapSelected === idx) {
        // 取消选择
        cell.classList.remove("selected");
        remapSelected = null;
        return;
    }

    // 交换 currentMapping 的两个位置并应用
    const newMap = currentMapping.slice();
    [newMap[idx], newMap[remapSelected]] = [newMap[remapSelected], newMap[idx]];
    remapSelected = null;
    applyPaletteMapping(newMap);
}

// 随机打乱（Fisher-Yates）, 并应用到画布（可撤回）
document.getElementById("shuffleColors").addEventListener("click", () => {
    const newMap = currentMapping.slice();
    for (let i = newMap.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [newMap[i], newMap[j]] = [newMap[j], newMap[i]];
    }
    applyPaletteMapping(newMap);
});

// 恢复原始顺序（把 mapping 还原为 basePalette, 然后应用）
document.getElementById("resetRemap").addEventListener("click", () => {
    applyPaletteMapping(basePalette.slice());
});

// 如果你在“添加颜色”时扩展了 colorPalette, 请在添加后调用 initRemapPanel()
// 例如：addColor 按钮成功加入后调用 initRemapPanel();


/* ====== 对称点 ====== */
function getSymmetryPoints(x, y) {
    const points = [{x, y}];
    const centerX = (COLS - 1) / 2;
    const centerY = (ROWS - 1) / 2;
    switch (symmetryMode) {
        case "horizontal":
            points.push({x: COLS - 1 - x, y});
            break;
        case "vertical":
            points.push({x, y: ROWS - 1 - y});
            break;
        case "both":
            points.push({x: COLS - 1 - x, y});
            points.push({x, y: ROWS - 1 - y});
            points.push({x: COLS - 1 - x, y: ROWS - 1 - y});
            break;
        case "rotate4": {
            const dx = x - centerX, dy = y - centerY;
            points.push({x: Math.round(centerX - dy), y: Math.round(centerY + dx)});
            points.push({x: Math.round(centerX - dx), y: Math.round(centerY - dy)});
            points.push({x: Math.round(centerX + dy), y: Math.round(centerY - dx)});
            break;
        }
        case "rotate8": {
            const dx = x - centerX, dy = y - centerY;
            points.push({x: Math.round(centerX - dy), y: Math.round(centerY + dx)});
            points.push({x: Math.round(centerX - dx), y: Math.round(centerY - dy)});
            points.push({x: Math.round(centerX + dy), y: Math.round(centerY - dx)});
            points.push({x: Math.round(centerX + dy), y: Math.round(centerY + dx)});
            points.push({x: Math.round(centerX - dy), y: Math.round(centerY - dx)});
            points.push({x: Math.round(centerX + dx), y: Math.round(centerY - dy)});
            points.push({x: Math.round(centerX - dx), y: Math.round(centerY + dy)});
            break;
        }
    }
    const seen = new Set();
    return points.filter(p => {
        if (p.x < 0 || p.x >= COLS || p.y < 0 || p.y >= ROWS) return false;
        const k = `${p.x},${p.y}`;
        if (seen.has(k)) return false;
        seen.add(k);
        return true;
    });
}

/* ====== 像素写入 ====== */
function setPixelDirect(x, y, color) {
    pixelData[y][x] = color;
    const pixel = canvas.querySelector(`.pixel[data-x="${x}"][data-y="${y}"]`);
    if (pixel) pixel.style.backgroundColor = color;
}

function drawPixel(x, y, colorOverride = null) {
    const color = colorOverride || ((tool === "eraser") ? colorPalette[0] : currentColor);
    const pts = getSymmetryPoints(x, y);
    pts.forEach(p => {
        const oldColor = pixelData[p.y][p.x];
        if (oldColor === color) return;
        if (currentStep) currentStep.push({x: p.x, y: p.y, oldColor, newColor: color});
        setPixelDirect(p.x, p.y, color);
    });
}

/* ====== 选区：渲染与工具（完全替换） ====== */
function updateSelectionBounds() {
    if (selectionPixels.size === 0) {
        selectionBounds = null;
        return;
    }
    let minX = COLS, minY = ROWS, maxX = 0, maxY = 0;
    selectionPixels.forEach(k => {
        const [x, y] = k.split(',').map(Number);
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
    });
    selectionBounds = {minX, minY, maxX, maxY};
}

function renderSelectionLayer() {
    selectionLayer.innerHTML = "";
    // 粘贴/移动预览优先显示（颜色块 + 斜线覆盖）
    if (clipboard && pasteOffset) {
        for (let sy = 0; sy < clipboard.h; sy++) {
            for (let sx = 0; sx < clipboard.w; sx++) {
                const col = clipboard.cells[sy][sx];
                if (col == null) continue;
                const x = pasteOffset.x + sx, y = pasteOffset.y + sy;
                if (x < 0 || x >= COLS || y < 0 || y >= ROWS) continue;
                const el = document.createElement('div');
                el.className = 'sel-preview';
                el.style.left = (x * PIXEL_SIZE) + 'px';
                el.style.top = (y * PIXEL_SIZE) + 'px';
                el.style.width = (PIXEL_SIZE) + 'px';
                el.style.height = (PIXEL_SIZE) + 'px';
                el.style.backgroundColor = col;
                selectionLayer.appendChild(el);
            }
        }
        // 边框
        const border = document.createElement('div');
        border.className = 'sel-border';
        border.style.left = (pasteOffset.x * PIXEL_SIZE) + 'px';
        border.style.top = (pasteOffset.y * PIXEL_SIZE) + 'px';
        border.style.width = (clipboard.w * PIXEL_SIZE) + 'px';
        border.style.height = (clipboard.h * PIXEL_SIZE) + 'px';
        selectionLayer.appendChild(border);
        return;
    }

    // 常规选区每像素显示斜线
    selectionPixels.forEach(k => {
        const [x, y] = k.split(',').map(Number);
        const el = document.createElement('div');
        el.className = 'sel-pixel';
        el.style.left = (x * PIXEL_SIZE) + 'px';
        el.style.top = (y * PIXEL_SIZE) + 'px';
        el.style.width = (PIXEL_SIZE) + 'px';
        el.style.height = (PIXEL_SIZE) + 'px';
        selectionLayer.appendChild(el);
    });
    if (selectionBounds) {
        const b = selectionBounds;
        const border = document.createElement('div');
        border.className = 'sel-border';
        border.style.left = (b.minX * PIXEL_SIZE) + 'px';
        border.style.top = (b.minY * PIXEL_SIZE) + 'px';
        border.style.width = ((b.maxX - b.minX + 1) * PIXEL_SIZE) + 'px';
        border.style.height = ((b.maxY - b.minY + 1) * PIXEL_SIZE) + 'px';
        selectionLayer.appendChild(border);
    }
}

function setSelectionFromRect(x1, y1, x2, y2, add = false) {
    if (!add) selectionPixels.clear();
    const minX = Math.max(0, Math.min(x1, x2));
    const maxX = Math.min(COLS - 1, Math.max(x1, x2));
    const minY = Math.max(0, Math.min(y1, y2));
    const maxY = Math.min(ROWS - 1, Math.max(y1, y2));
    for (let y = minY; y <= maxY; y++) for (let x = minX; x <= maxX; x++) selectionPixels.add(`${x},${y}`);
    updateSelectionBounds();
    renderSelectionLayer();
}

/* 手涂选区：逐像素切换（按下并拖动会按格切换一次） */
function toggleSelectionPixel(x, y) {
    const k = `${x},${y}`;
    if (selectionPixels.has(k)) selectionPixels.delete(k);
    else selectionPixels.add(k);
    updateSelectionBounds();
    renderSelectionLayer();
}

/* 剪贴板操作 */
function copySelection() {
    if (!selectionBounds) return alert('没有选区');
    const b = selectionBounds;
    const w = b.maxX - b.minX + 1, h = b.maxY - b.minY + 1;
    const cells = Array.from({length: h}, () => Array.from({length: w}, () => null));
    for (let y = b.minY; y <= b.maxY; y++) {
        for (let x = b.minX; x <= b.maxX; x++) {
            const k = `${x},${y}`;
            if (selectionPixels.has(k)) cells[y - b.minY][x - b.minX] = pixelData[y][x];
            else cells[y - b.minY][x - b.minX] = null;
        }
    }
    clipboard = {w, h, cells};
    pasteOffset = {x: b.minX, y: b.minY};
    // clear moveOrigin if any
    moveOrigin = null;
    renderSelectionLayer();
}

function cutSelection() {
    if (!selectionBounds) return alert('没有选区');
    copySelection();
    const toColor = colorPalette[0];
    const step = [];
    selectionPixels.forEach(k => {
        const [x, y] = k.split(',').map(Number);
        step.push({x, y, oldColor: pixelData[y][x], newColor: toColor});
        setPixelDirect(x, y, toColor);
    });
    pushHistory(step);
    selectionPixels.clear();
    updateSelectionBounds();
    renderSelectionLayer();
}

/* 开始粘贴（或移动）预览 — 粘贴由 beginPaste() 启动, 回车 applyPaste() */
function beginPaste() {
    if (!clipboard) return alert('剪贴板为空');

    // currentMousePos 应该是画布格坐标 {x, y}（不是 clientX/clientY）
    const pos = (typeof currentMousePos !== 'undefined' && currentMousePos) ? currentMousePos : null;

    // 想把粘贴区域“居中放到鼠标处”, 计算期望的左上角
    const desiredX = pos ? (pos.x - Math.floor(clipboard.w / 2)) : (selectionBounds ? selectionBounds.minX : 0);
    const desiredY = pos ? (pos.y - Math.floor(clipboard.h / 2)) : (selectionBounds ? selectionBounds.minY : 0);

    // 最大允许的偏移（防止越界）, 若 clipboard 比画布大则 maxOffsetX/Y = 0
    const maxOffsetX = Math.max(0, COLS - clipboard.w);
    const maxOffsetY = Math.max(0, ROWS - clipboard.h);

    // 钳制到 [0, maxOffset]
    pasteOffset = {
        x: Math.max(0, Math.min(maxOffsetX, desiredX)),
        y: Math.max(0, Math.min(maxOffsetY, desiredY))
    };

    selectionMode = 'paste';
    renderSelectionLayer();
}

/* 移动选区（将当前选区内容复制到 clipboard, 等待粘贴；确认后原位清空） */
function beginMove() {
    if (!selectionBounds) return alert('没有选区');
    // copy selection to clipboard
    moveBackup = [];

    const b = selectionBounds;
    const w = b.maxX - b.minX + 1, h = b.maxY - b.minY + 1;
    const cells = Array.from({length: h}, () => Array.from({length: w}, () => null));
    const origin = [];
    for (let y = b.minY; y <= b.maxY; y++) {
        for (let x = b.minX; x <= b.maxX; x++) {
            const k = `${x},${y}`;
            if (selectionPixels.has(k)) {
                cells[y - b.minY][x - b.minX] = pixelData[y][x];
                origin.push({x, y, oldColor: pixelData[y][x]});
            } else cells[y - b.minY][x - b.minX] = null;
        }
    }
    clipboard = {w, h, cells};
    pasteOffset = {x: b.minX, y: b.minY};

    moveOrigin = origin; // will be cleared on confirm
    selectionMode = 'move';

    const step = [];
    // 如果是 move 操作, 清空原点（把origin像素设为空白）
    if (moveOrigin && moveOrigin.length > 0) {
        moveOrigin.forEach(o => {
            // 若原位置正好被新放置覆盖（坐标冲突）, oldColor already preserved; we still set to blank if not overlapped by new placement
            // For simplicity, set to palette[0] and record step
            step.push({x: o.x, y: o.y, oldColor: pixelData[o.y][o.x], newColor: colorPalette[0]});
            setPixelDirect(o.x, o.y, colorPalette[0]);
        });
    }
    if (step.length > 0) pushHistory(step);

    renderSelectionLayer();
}

/* 确认粘贴/移动：写入像素并记录历史（移动会同时清空原处） */
function applyPaste() {
    if (!clipboard || !pasteOffset) return;
    const step = [];
    for (let sy = 0; sy < clipboard.h; sy++) {
        for (let sx = 0; sx < clipboard.w; sx++) {
            const col = clipboard.cells[sy][sx];
            if (col == null) continue;
            const tx = pasteOffset.x + sx, ty = pasteOffset.y + sy;
            if (tx < 0 || tx >= COLS || ty < 0 || ty >= ROWS) continue;
            step.push({x: tx, y: ty, oldColor: pixelData[ty][tx], newColor: col});
            setPixelDirect(tx, ty, col);
        }
    }

    if (step.length > 0) pushHistory(step);
    // 清理
    // clipboard = null;
    pasteOffset = null;
    moveOrigin = null;
    selectionMode = null;
    setActiveSelection(null)
    selectionPixels.clear();
    updateSelectionBounds();
    renderSelectionLayer();
}

/* 取消选区/粘贴 */
function clearSelection() {
    // clipboard = null;
    selectionPixels.clear();
    selectionBounds = null;
    pasteOffset = null;
    moveOrigin = null;
    selectionMode = null;
    setActiveSelection(null)
    renderSelectionLayer();
}

/* ====== 历史（撤回/重做） ====== */
function pushHistory(step) {
    if (!step || step.length === 0) return;
    historyStack.push(step);
    if (historyStack.length > MAX_HISTORY) historyStack.shift();
    redoStack = [];
}

function undo() {
    const step = historyStack.pop();
    if (!step) return;
    step.forEach(p => setPixelDirect(p.x, p.y, p.oldColor));
    redoStack.push(step);
}

function redo() {
    const step = redoStack.pop();
    if (!step) return;
    step.forEach(p => setPixelDirect(p.x, p.y, p.newColor));
    historyStack.push(step);
}

/* ====== 图形工具（preview 支持） ====== */
function getLinePixels(x1, y1, x2, y2) {
    const pixels = [];
    let dx = Math.abs(x2 - x1), dy = Math.abs(y2 - y1);
    let sx = x1 < x2 ? 1 : -1, sy = y1 < y2 ? 1 : -1;
    let err = dx - dy;
    while (true) {
        pixels.push({x: x1, y: y1});
        if (x1 === x2 && y1 === y2) break;
        let e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x1 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y1 += sy;
        }
    }
    return pixels;
}

function getRectPixels(x1, y1, x2, y2, hollow = false) {
    const pixels = [];
    const minX = Math.min(x1, x2), maxX = Math.max(x1, x2), minY = Math.min(y1, y2), maxY = Math.max(y1, y2);
    for (let y = minY; y <= maxY; y++) for (let x = minX; x <= maxX; x++) {
        if (hollow) {
            if (x === minX || x === maxX || y === minY || y === maxY) pixels.push({x, y});
        } else pixels.push({x, y});
    }
    return pixels;
}

function getCirclePixels(cx, cy, r, hollow = false) {
    const pixels = [];
    for (let dy = -r; dy <= r; dy++) {
        for (let dx = -r; dx <= r; dx++) {
            const dist2 = dx * dx + dy * dy;
            if (hollow) {
                if (Math.abs(dist2 - r * r) <= Math.max(1, r)) pixels.push({x: cx + dx, y: cy + dy});
            } else {
                if (dist2 <= r * r) pixels.push({x: cx + dx, y: cy + dy});
            }
        }
    }
    return pixels;
}

/* ====== Flood Fill ====== */
function floodFill(x, y, targetColor, newColor, previewOnly = false) {
    if (targetColor === newColor) return [];
    const stack = [{x, y}];
    const visited = new Set();
    const pixels = [];
    while (stack.length) {
        const p = stack.pop();
        if (p.x < 0 || p.x >= COLS || p.y < 0 || p.y >= ROWS) continue;
        const key = `${p.x},${p.y}`;
        if (visited.has(key)) continue;
        visited.add(key);
        if (pixelData[p.y][p.x] !== targetColor) continue;
        pixels.push({x: p.x, y: p.y});
        stack.push({x: p.x + 1, y: p.y});
        stack.push({x: p.x - 1, y: p.y});
        stack.push({x: p.x, y: p.y + 1});
        stack.push({x: p.x, y: p.y - 1});
    }
    if (previewOnly) return pixels;
    const step = [];
    pixels.forEach(p => {
        step.push({x: p.x, y: p.y, oldColor: pixelData[p.y][p.x], newColor});
        setPixelDirect(p.x, p.y, newColor);
    });
    if (step.length > 0) pushHistory(step);
    return pixels;
}

/* ====== 预览绘制（画图形） ====== */
function renderPreview(pixels) {
    previewLayer.innerHTML = "";
    if (!pixels || pixels.length === 0) return;
    pixels.forEach(p => {
        const el = document.createElement("div");
        el.style.position = "absolute";
        el.style.width = PIXEL_SIZE + "px";
        el.style.height = PIXEL_SIZE + "px";
        el.style.left = (p.x * PIXEL_SIZE) + "px";
        el.style.top = (p.y * PIXEL_SIZE) + "px";
        el.style.backgroundColor = currentColor;
        el.style.opacity = 0.35;
        previewLayer.appendChild(el);
    });
}

/* ====== 导出/导入（恢复原版格式） ====== */
function exportAsText() {
    let out = "";
    for (let y = 0; y < ROWS; y++) {
        out += "- [";
        const row = [];
        for (let x = 0; x < COLS; x++) {
            const idx = colorPalette.indexOf(pixelData[y][x]);
            row.push(idx >= 0 ? idx.toString(16).toUpperCase() : "0");
        }
        out += row.join(", ") + "]\n";
    }
    exportOutput.value = out;

    // 将结果复制到剪贴板
    navigator.clipboard.writeText(out).then(() => {
        showToast('导出的内容已复制到剪贴板');
    }).catch(err => {
        showToast('无法复制到剪贴板: ', err);
    });

}

function importFromText() {
    const text = exportOutput.value.trim();
    if (!text) {
        // 如果输入区域为空，尝试从剪贴板导入
        navigator.clipboard.readText().then(clipboardText => {
            const trimmedText = clipboardText.trim();
            if (trimmedText) {
                try {
                    const lines = trimmedText.split("\n")
                        .map(l => l.trim())
                        .filter(l => l.length !== 0)
                        .map(line => line.replace(/^- +\[/, '').replace(/]$/, ''))
                        .filter(l => l.trim());
                    const newRows = lines.length;
                    const newCols = lines[0].split(",").length;

                    // 计算偏移量，以便在新画布上居中显示图像
                    let offsetX = Math.floor((COLS - newCols) / 2);
                    let offsetY = Math.floor((ROWS - newRows) / 2);

                    // 如果新的尺寸超过了当前画布尺寸，调整偏移量
                    if (newCols > COLS) offsetX = 0;
                    if (newRows > ROWS) offsetY = 0;

                    const imported = [];
                    for (let y = 0; y < ROWS; y++) {
                        const row = [];
                        for (let x = 0; x < COLS; x++) {
                            // 计算对应于原图的位置
                            const srcX = x - offsetX;
                            const srcY = y - offsetY;

                            // 如果超出原图范围，则填充背景色
                            if (srcX < 0 || srcX >= newCols || srcY < 0 || srcY >= newRows) {
                                row.push(colorPalette[0]); // 假设索引0为背景色
                            } else {
                                const v = lines[srcY].split(",")[srcX].trim().toUpperCase();
                                let idx = null;
                                if (/^[0-9A-F]$/.test(v)) idx = parseInt(v, 16); else idx = parseInt(v, 10);
                                if (isNaN(idx) || idx < 0 || idx >= colorPalette.length) throw new Error(`颜色索引无效: ${v}`);
                                row.push(colorPalette[idx]);
                            }
                        }
                        imported.push(row);
                        showToast('成功导入！');
                    }

                    // 更新画布尺寸
                    // document.getElementById("canvasWidth").value = COLS;
                    // document.getElementById("canvasHeight").value = ROWS;
                    pixelData = imported;
                    initCanvas();
                } catch (err) {
                    showToast("导入失败: " + err.message);
                }
            } else {
                showToast("请先粘贴像素画数据");
            }
        }).catch(err => {
            console.error('无法读取剪贴板: ', err);
            showToast("无法读取剪贴板，请手动粘贴数据");
        });
    } else {
        try {
            const lines = text.split("\n")
                .map(l => l.trim())
                .filter(l => l.length !== 0)
                .map(line => line.replace(/^- +\[/, '').replace(/]$/, ''))
                .filter(l => l.trim());
            const newRows = lines.length;
            const newCols = lines[0].split(",").length;

            // 计算偏移量，以便在新画布上居中显示图像
            let offsetX = Math.floor((COLS - newCols) / 2);
            let offsetY = Math.floor((ROWS - newRows) / 2);

            // 如果新的尺寸超过了当前画布尺寸，调整偏移量
            if (newCols > COLS) offsetX = 0;
            if (newRows > ROWS) offsetY = 0;

            const imported = [];
            for (let y = 0; y < ROWS; y++) {
                const row = [];
                for (let x = 0; x < COLS; x++) {
                    // 计算对应于原图的位置
                    const srcX = x - offsetX;
                    const srcY = y - offsetY;

                    // 如果超出原图范围，则填充背景色
                    if (srcX < 0 || srcX >= newCols || srcY < 0 || srcY >= newRows) {
                        row.push(colorPalette[0]); // 假设索引0为背景色
                    } else {
                        const v = lines[srcY].split(",")[srcX].trim().toUpperCase();
                        let idx = null;
                        if (/^[0-9A-F]$/.test(v)) idx = parseInt(v, 16); else idx = parseInt(v, 10);
                        if (isNaN(idx) || idx < 0 || idx >= colorPalette.length) throw new Error(`颜色索引无效: ${v}`);
                        row.push(colorPalette[idx]);
                    }
                }
                imported.push(row);
                showToast('成功导入！');
            }

            // 更新画布尺寸
            // document.getElementById("canvasWidth").value = COLS;
            // document.getElementById("canvasHeight").value = ROWS;
            pixelData = imported;
            initCanvas();
        } catch (err) {
            showToast("导入失败: " + err.message);
        }
    }
}

function showToast(message) {
        const toast = document.createElement('div');
        toast.className = 'toast';
        toast.innerText = message;

        document.body.appendChild(toast);

        setTimeout(() => {
            toast.classList.add('show');

            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    document.body.removeChild(toast);
                }, 300); // 等待过渡效果完成
            }, 2000); // 显示时间
        }, 10); // 确保元素被添加到DOM后立即开始动画
    }


/* ====== 鼠标坐标映射 ====== */
function getPixelFromEvent(e) {
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) / PIXEL_SIZE);
    const y = Math.floor((e.clientY - rect.top) / PIXEL_SIZE);
    if (x >= 0 && x < COLS && y >= 0 && y < ROWS) return {x, y};
    return null;
}

/* ====== 事件处理 ====== */
let isDrawing = false;
let startX = null, startY = null;

function setupEventListeners() {
    // 恢复：关闭/刷新前提示（原版）
    window.addEventListener("beforeunload", (e) => {
        e.preventDefault();
        e.returnValue = "⚠️ 数据将不会保存, 确定退出吗？";
    });

    function activateToolButton(btnId, toolName) {
        const btn = document.getElementById(btnId);
        btn.addEventListener("click", () => {
            tool = toolName;
            document.querySelectorAll(".btn-group button").forEach(b => b.classList.remove("active"));
            refreshSymmetry()
            btn.classList.add("active");
            previewLayer.innerHTML = "";
            startX = startY = null;
            isDrawing = false;
        });
    }

    activateToolButton("pen", "pen");
    activateToolButton("eraser", "eraser");
    activateToolButton("line", "line");
    activateToolButton("rect", "rect");
    activateToolButton("circle", "circle");
    activateToolButton("fill", "fill");
    activateToolButton("eyedropper", "eyedropper");

    // 选区按钮（+ hover 提示）
    document.getElementById('selRect').addEventListener('click', () => {
        selectionMode = 'rect';
        selectionPixels.clear();
        selectionBounds = null;
        setActiveSelection('selRect');
        renderSelectionLayer();
    });

    document.getElementById('selFree').addEventListener('click', () => {
        selectionMode = 'free';
        selectionPixels.clear();
        selectionBounds = null;
        setActiveSelection('selFree');
        renderSelectionLayer();
    });
    document.getElementById('selMove').addEventListener('click', () => {
        if (!selectionBounds) return alert('先选区再移动');
        beginMove();
    });
    document.getElementById('selCopy').addEventListener('click', () => {
        copySelection();
    });
    document.getElementById('selCut').addEventListener('click', () => {
        cutSelection();
    });
    document.getElementById('selPaste').addEventListener('click', () => {
        beginPaste();
    });
    document.getElementById('selClear').addEventListener('click', () => {
        clearSelection();
    });

    // 撤回/重做/清空/导出/导入/添加颜色/resize
    document.getElementById("undo").addEventListener("click", undo);
    document.getElementById("redo").addEventListener("click", redo);
    document.getElementById("clear").addEventListener("click", () => {
        if (!confirm("确定要清空画布吗？")) return;
        initData();
        initCanvas();
        historyStack = [];
        redoStack = [];
    });
    document.getElementById("toggleGrid").addEventListener("click", () => {
        const wrapper = document.getElementById("canvasWrapper");
        wrapper.classList.toggle("no-grid");
    });
    document.getElementById("exportBtn").addEventListener("click", exportAsText);
    document.getElementById("importBtn").addEventListener("click", importFromText);
    // ======= 导入图片 ======

    document.getElementById("importImage").addEventListener("click", () => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = "image/*";
        input.onchange = e => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = ev => importImageToCanvas(ev.target.result);
            reader.readAsDataURL(file);
        };
        input.click();
    });

    async function importImageToCanvas(dataUrl) {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => {
            // 创建离屏 canvas 缩放图像
            const off = document.createElement("canvas");
            off.width = COLS;
            off.height = ROWS;
            const ctx = off.getContext("2d", {willReadFrequently: true});
            ctx.imageSmoothingEnabled = false;//邻近缩放
            ctx.drawImage(img, 0, 0, off.width, off.height);
            const imgData = ctx.getImageData(0, 0, off.width, off.height).data;

            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const i = (y * COLS + x) * 4;
                    const r = imgData[i];
                    const g = imgData[i + 1];
                    const b = imgData[i + 2];
                    const color = rgbToHex(r, g, b);
                    const nearest = findNearestPaletteColor(colorPalette, color);
                    pixelData[y][x] = nearest;
                    const px = canvas.querySelector(`.pixel[data-x="${x}"][data-y="${y}"]`);
                    if (px) px.style.backgroundColor = nearest;
                }
            }
        };
        img.src = dataUrl;
    }

    // 将 RGB 转 16 进制
    function rgbToHex(r, g, b) {
        return "#" + [r, g, b].map(v => v.toString(16).padStart(2, "0")).join("");
    }

    // 查找调色板中最接近的颜色
    function findNearestPaletteColor(palette, targetHex) {
        const [r1, g1, b1] = hexToRgb(targetHex);
        let minDist = Infinity, nearest = palette[0];
        for (const c of palette) {
            const [r2, g2, b2] = hexToRgb(c);
            const d = (r1 - r2) ** 2 + (g1 - g2) ** 2 + (b1 - b2) ** 2;
            if (d < minDist) {
                minDist = d;
                nearest = c;
            }
        }
        return nearest;
    }

    // HEX 转 RGB
    function hexToRgb(hex) {
        const n = parseInt(hex.slice(1), 16);
        return [(n >> 16) & 255, (n >> 8) & 255, n & 255];
    }


    // ======= 添加颜色 ======
    // document.getElementById("addColor").addEventListener("click", ()=>{
    //   const color = document.getElementById("colorPicker").value.toUpperCase();
    //   if (colorPalette.length >= colorPalette.length){} // noop (kept original behavior)
    //   if (!colorPalette.includes(color)){
    //     if (colorPalette.length >= 16){ alert("调色板已满"); return; }
    //     colorPalette.push(color);
    //     renderColorPalette();
    //     const last = colorPaletteContainer.querySelectorAll(".color-btn");
    //     last[last.length-1].click();
    //   } else alert("该颜色已存在");
    // });

    // document.getElementById("resizeCanvas").addEventListener("click", ()=>{
    //   const newW = parseInt(document.getElementById("canvasWidth").value);
    //   const newH = parseInt(document.getElementById("canvasHeight").value);
    //   if (newW>=5 && newW<=100 && newH>=5 && newH<=100){
    //     COLS = newW; ROWS = newH;
    //     initData(); initCanvas();
    //     historyStack=[]; redoStack=[];
    //   } else alert("尺寸必须在5-100之间");
    // });

    // symmetry
    document.querySelectorAll(".symmetry-btn").forEach(btn => {
        btn.addEventListener("click", function () {
            document.querySelectorAll(".symmetry-btn").forEach(b => b.classList.remove("active"));
            this.classList.add("active");
            symmetryMode = this.dataset.mode;
        });
    });
    document.querySelector('.symmetry-btn[data-mode="none"]').classList.add("active");

    // Canvas 鼠标逻辑
    canvas.addEventListener("mousedown", (e) => {
        if (e.button !== 0) return;
        const pos = getPixelFromEvent(e);
        if (!pos) return;

        // 选区模式：矩形 / 手涂 / 粘贴移动
        if (selectionMode === 'rect') {
            isSelecting = true;
            dragStart = pos;
            lastToggledKey = null;
            return;
        }
        if (selectionMode === 'free') {
            isSelecting = true;
            dragStart = pos;
            lastToggledKey = `${pos.x},${pos.y}`;
            toggleSelectionPixel(pos.x, pos.y);
            return;
        }
        if ((selectionMode === 'paste' || selectionMode === 'move') && clipboard) {
            isDraggingPaste = true;
            dragStart = pos;
            return;
        }

        // 常规绘图
        if (tool === "pen" || tool === "eraser") {
            isDrawing = true;
            currentStep = [];
            drawPixel(pos.x, pos.y, null); // drawPixel 记录到 currentStep
            canvas._curStep = currentStep;
            return;
        }

        if (tool === "eyedropper") {
            if (!pos) return;
            const pickedColor = pixelData[pos.y][pos.x];
            if (pickedColor) {
                currentColor = pickedColor;
                document.querySelectorAll(".color-btn").forEach(x => x.classList.remove("selected"));
                const colorBtns = colorPaletteContainer.querySelectorAll(".color-btn");
                const idx = colorPalette.indexOf(pickedColor);
                if (colorBtns[idx]) colorBtns[idx].classList.add("selected");
            }
            previewLayer.innerHTML = "";
            return;
        }
        if (tool === "fill") {
            const targetColor = pixelData[pos.y][pos.x];
            const newColor = currentColor;
            if (targetColor !== newColor) {
                floodFill(pos.x, pos.y, targetColor, newColor, false);
            }
            previewLayer.innerHTML = "";
            return;
        }
        if (tool === "line" || tool === "rect" || tool === "circle") {
            startX = pos.x;
            startY = pos.y;
        }
    });

    canvas.addEventListener("mousemove", (e) => {
        const pos = getPixelFromEvent(e);
        if (!pos) return;
        currentMousePos = pos

        // 矩形选取拖动：按 Shift 叠加（add=true）
        if (isSelecting && selectionMode === 'rect' && dragStart) {
            const add = e.shiftKey;
            setSelectionFromRect(dragStart.x, dragStart.y, pos.x, pos.y, add);
            return;
        }
        // 手涂选取：逐像素切换（进入新像素才切换一次）
        if (isSelecting && selectionMode === 'free') {
            const key = `${pos.x},${pos.y}`;
            if (key !== lastToggledKey) {
                toggleSelectionPixel(pos.x, pos.y);
                lastToggledKey = key;
            }
            return;
        }
        // 粘贴/移动拖动预览
        if (isDraggingPaste && clipboard && (selectionMode === 'paste' || selectionMode === 'move')) {
            const dx = pos.x - dragStart.x, dy = pos.y - dragStart.y;
            pasteOffset = {
                x: Math.max(-clipboard.w, Math.min(COLS, pasteOffset.x + dx)),
                y: Math.max(-clipboard.h, Math.min(ROWS, pasteOffset.y + dy))
            };
            dragStart = pos;
            renderSelectionLayer();
            return;
        }

        // 绘图拖动
        if (isDrawing && (tool === "pen" || tool === "eraser")) {
            drawPixel(pos.x, pos.y, null);
            return;
        }

        // 形状预览
        if (startX !== null && startY !== null) {
            const hollow = e.shiftKey;
            let pixels = [];
            if (tool === "line") pixels = getLinePixels(startX, startY, pos.x, pos.y);
            else if (tool === "rect") pixels = getRectPixels(startX, startY, pos.x, pos.y, hollow);
            else if (tool === "circle") {
                const r = Math.round(Math.sqrt((pos.x - startX) ** 2 + (pos.y - startY) ** 2));
                pixels = getCirclePixels(startX, startY, r, hollow);
            }
            renderPreview(pixels);
        }
    });

    document.addEventListener("mouseup", (e) => {
        const pos = getPixelFromEvent(e);

        // 结束选区
        if (isSelecting && selectionMode === 'rect') {
            isSelecting = false;
            dragStart = null;
            return;
        }
        if (isSelecting && selectionMode === 'free') {
            isSelecting = false;
            dragStart = null;
            lastToggledKey = null;
            return;
        }
        if (isDraggingPaste) {
            isDraggingPaste = false;
            dragStart = null;
            return;
        }

        // 绘图结束 -> 历史记录
        if (isDrawing) {
            isDrawing = false;
            if (canvas._curStep && canvas._curStep.length > 0) {
                pushHistory(canvas._curStep);
                canvas._curStep = null;
                currentStep = null;
            }
        }

        // 形状提交
        if (startX !== null && startY !== null && pos) {
            const hollow = e.shiftKey;
            currentStep = [];
            if (tool === "line") {
                const pts = getLinePixels(startX, startY, pos.x, pos.y);
                pts.forEach(p => drawPixel(p.x, p.y, null));
            } else if (tool === "rect") {
                const pts = getRectPixels(startX, startY, pos.x, pos.y, hollow);
                pts.forEach(p => drawPixel(p.x, p.y, null));
            } else if (tool === "circle") {
                const r = Math.round(Math.sqrt((pos.x - startX) ** 2 + (pos.y - startY) ** 2));
                const pts = getCirclePixels(startX, startY, r, hollow);
                pts.forEach(p => drawPixel(p.x, p.y, null));
            }
            if (currentStep && currentStep.length > 0) {
                pushHistory(currentStep);
                currentStep = null;
            }
        }

        startX = startY = null;
        previewLayer.innerHTML = "";
    });

    // 键盘：Enter 确认粘贴/移动；Esc 清除；Ctrl 快捷键（但如果焦点在输入框/文本域/可编辑元素中则放行原生）
    document.addEventListener('keydown', (e) => {
        const tag = document.activeElement && document.activeElement.tagName ? document.activeElement.tagName.toLowerCase() : '';
        const inInput = (tag === 'input' || tag === 'textarea' || document.activeElement && document.activeElement.isContentEditable);

        if (e.key === 'Enter') {
            if (selectionMode === 'paste' && clipboard) {
                applyPaste();
            } else if (selectionMode === 'move' && clipboard) {
                applyPaste();
            }
        }
        if (e.key === 'Escape') {
            clearSelection();
            previewLayer.innerHTML = "";
        }

        if (!inInput) {
            if (e.ctrlKey && e.key.toLowerCase() === 'c') {
                e.preventDefault();
                copySelection();
            }
            if (e.ctrlKey && e.key.toLowerCase() === 'x') {
                e.preventDefault();
                cutSelection();
            }
            if (e.ctrlKey && e.key.toLowerCase() === 'v') {
                e.preventDefault();
                beginPaste();
            }
            if (e.ctrlKey && e.key.toLowerCase() === 'z') {
                e.preventDefault();
                undo();
            }
            if (e.ctrlKey && e.key.toLowerCase() === 'y') {
                e.preventDefault();
                redo();
            }
        }

        if ((e.key === 'Alt' || e.code === 'AltLeft' || e.code === 'AltRight') && !isColorPicking) {
            e.preventDefault();
            isColorPicking = true;
            previousTool = tool; // 注意这里改为切换主工具变量
            setActiveTool('eyedropper');
        }

    });

    document.addEventListener('keyup', (e) => {
        if ((e.key === 'Alt' || e.code === 'AltLeft' || e.code === 'AltRight') && isColorPicking) {
            isColorPicking = false;
            setActiveTool(previousTool || 'pen');
            previousTool = null;
        }
    });

    // 🧭 防止 Alt+Tab 后卡在取色模式
    window.addEventListener("blur", () => {
        // 当窗口失焦时标记状态
        if (isColorPicking) {
            window._wasColorPicking = true;
        }
    });

    window.addEventListener("focus", () => {
        // 如果失焦时正在取色, 则强制恢复原工具
        if (window._wasColorPicking) {
            window._wasColorPicking = false;
            isColorPicking = false;
            setActiveTool(previousTool || "pen");
            previousTool = null;
        }
    });


    // 防拖拽
    canvas.addEventListener("dragstart", (e) => {
        e.preventDefault();
        return false;
    });
}

/* ====== 渲染颜色面板 ====== */
function renderColorPalette() {
    colorPaletteContainer.innerHTML = "";
    colorPalette.forEach((c, i) => {
        const b = document.createElement("div");
        b.className = "color-btn";
        b.style.backgroundColor = c;
        b.dataset.color = c;
        b.title = `${i}: ${c}`;
        if (i === 3) b.classList.add("selected");
        b.addEventListener("click", () => {
            document.querySelectorAll(".color-btn").forEach(x => x.classList.remove("selected"));
            b.classList.add("selected");
            currentColor = c;
        });
        colorPaletteContainer.appendChild(b);
    });
    const info = document.createElement("div");
    info.style.cssText = "width:100%;text-align:center;margin-top:6px;font-size:12px;color:#666";
    //info.textContent = `${colorPalette.length} / 16 颜色`;
    colorPaletteContainer.appendChild(info);
}

/* ====== 初始化入口 ====== */
(function initAll() {
    initData();
    renderColorPalette();
    initRemapPanel();
    initCanvas();
    setupEventListeners();
})();

function handleUnlockClick() {
    // 打开新标签页
    window.open('https://live.bilibili.com/52030', '_blank');

    // 获取按钮元素
    var button = document.getElementById('unlock');

    // 修改按钮文本
    button.textContent = '已激活';

    // 修改按钮样式
    button.style.backgroundColor = '#ccc';  // 灰色背景
    button.style.color = '#666';            // 深灰色文字
    button.style.cursor = 'not-allowed';     // 鼠标指针变为不允许
    button.disabled = true;                 // 禁用按钮

    spawnToyAvatar()
}

    /* Toy avatar: create, click squeeze animation, and play a "doll squeak" using WebAudio.
   Usage:
     - call spawnToyAvatar() to spawn the avatar (idempotent).
     - or bind spawnToyAvatar to a button click (see example below).
*/

// 保证只创建一次
let _toyAvatarCreated = false;
let _audioCtx = null;

// 生成并播放一次短促玩偶声（合成，不依赖音频文件）
function playToySqueak() {
  try {
    if (!_audioCtx) _audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const ctx = _audioCtx;

    const now = ctx.currentTime;

    // 主音：快速上行频率的正弦（squeak）
    const osc = ctx.createOscillator();
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(600, now);
    osc.frequency.exponentialRampToValueAtTime(1400, now + 0.12);

    // 短包络
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0, now);
    g.gain.linearRampToValueAtTime(0.9, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + 0.28);

    // 叠加一层噪声（轻微气声）
    const bufferSize = 2 * ctx.sampleRate;
    const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const output = noiseBuffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) output[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);

    const noise = ctx.createBufferSource();
    noise.buffer = noiseBuffer;

    const noiseFilter = ctx.createBiquadFilter();
    noiseFilter.type = 'bandpass';
    noiseFilter.frequency.value = 1600;
    noiseFilter.Q.value = 0.7;

    const ng = ctx.createGain();
    ng.gain.setValueAtTime(0.0005, now);
    ng.gain.exponentialRampToValueAtTime(0.05, now + 0.01);
    ng.gain.exponentialRampToValueAtTime(0.00001, now + 0.18);

    // 混合输出到 destination（可加个 compressor 或 master gain）
    const master = ctx.createGain();
    master.gain.value = 0.9;

    osc.connect(g);
    g.connect(master);

    noise.connect(noiseFilter);
    noiseFilter.connect(ng);
    ng.connect(master);

    master.connect(ctx.destination);

    osc.start(now);
    noise.start(now);

    osc.stop(now + 0.32);
    noise.stop(now + 0.32);

    // 清理连接（浏览器会自动释放源，但切断引用以便 GC）
    setTimeout(()=> {
      try { osc.disconnect(); noise.disconnect(); g.disconnect(); ng.disconnect(); master.disconnect(); noiseFilter.disconnect(); } catch(e){}
    }, 500);
  } catch (err) {
    console.warn('Audio not available:', err);
  }
}

function spawnToyAvatar() {
  if (_toyAvatarCreated) return;
  _toyAvatarCreated = true;

  const avatar = document.createElement('div');
  avatar.id = 'toyAvatar';
  avatar.setAttribute('role','button');

  const hint = document.createElement('div');
  hint.className = 'hint';
  hint.textContent = '🎵';
  avatar.appendChild(hint);

  avatar.innerHTML += `<img src="./aza.webp"/>`;

  document.body.appendChild(avatar);

  avatar.addEventListener('click', (e) => {
    avatar.classList.remove('squeeze');
    void avatar.offsetWidth;
    avatar.classList.add('squeeze');
    playToySqueak();
  });
  avatar.addEventListener('mousedown', () => avatar.style.transform = 'scale(0.98)');
  avatar.addEventListener('mouseup', () => avatar.style.transform = '');
  avatar.addEventListener('mouseleave', () => avatar.style.transform = '');

}

</script>
<div style="text-align: center;">
    <a>
        &copy; 2025 Astrorbits NMBCT™ §AZA圣诞活动专用§
    </a>
</div>
</body>
</html>
